class Solution {
  public:
    string longestPalindrome(string s)
    {
        int start  = 0;
        int maxlen = 1;
        int length = s.size();

        int** a = new int*[length];
        for (int i = 0; i < length; i++) {
            a[i]    = new int[length]();
            a[i][i] = 1;
        }
        for (int cross = 1; cross < length; cross++) {
            for (int i = 0; i < length - cross; i++) {
                if (s[i] == s[i + cross]) {
                    a[i][i + cross] = a[i + 1][i + cross - 1] + 2;
                    if (a[i][i + cross] == cross + 1) {
                        maxlen = cross + 1;
                        start  = i;
                    }
                }
            }
        }
        return s.substr(start, maxlen);
    }
};
// @lc code=end
/*
 * @lc app=leetcode.cn id=5 lang=cpp
 *
 * [5] 最长回文子串
 */

/*

22:28 开始
22:35 看答案
22:42 开始写
23:05 调试
23:05 提交1
23:42 bug2
23:05 提交2
23:55 提交3

开始
感觉是动规题，O(n)
a 1
比如设置一个52×52的vector。先把二元组的信息输入，再试图从表格中相对称的两个格子中找到回文子串的起点和终点位置。然后再逐一比较。这种方法至少要遍历52×52/2，耗时

答案：动态规划O(n^2)
P(i,j)=P(i+1,j−1)∧(Si==Sj)
P(n,n)=1;P(n,n+1)=0/2

开始写
以后写leetcode，在开始前写写下先写什么，再写什么
c++获得二维数组的方法：
        int** a      = new int*[length];
        for (int i = 0; i < length;i++){
            a[i] = new int[length];
a[1,2]=a[2,1]+2,也是符合逻辑的

i < length -
cross：比如length=5，cross=1代表长度为2，那么最后一个访问节点是3，即i<4=5-1

调试
bug1 没有初始化
a[i]    = new int[length];
a[i]    = new int[length]();

提交一
"aacabdkacaa"
"aacabdkacaa"
"aca"
ps:这里不适合用动态规划的原因：每个格子的数值只用一次。

bug2
if (a[i][i + cross] > max) {
if (a[i][i + cross] == cross+1) {
动规格子只有等于特定值的时候才是有效的，其实可以等价使用bool数组就可以了。
这样写完之后还有一个副效果，即最终获得的最长回文串总是最后一个可能的情况。

提交2 time limit exceed
"0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"
可能是复制substr花了很多时间

提交3
176/176 cases passed (324 ms)
Your runtime beats 47.93 % of cpp submissions
Your memory usage beats 5.09 % of cpp submissions (397.8 MB)

官方解答：中心扩展算法即暴力算法。时间和动规一样，空间O(1)。
只能说，不考虑最后一个特殊解法，本题没有比暴力更高效的做法。
*/
