class Solution {
  public:
    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {}
};
// @lc code=end
/*
 * @lc app=leetcode.cn id=4 lang=cpp
 *
 * [4] 寻找两个正序数组的中位数
 */

/*
19:45 开始
19:54 fail
19:55 看提示
20:57 休息


可能思路：
1. 6个数字 as am ab和bm
每次都可以选择其中的一半
a. 126 345->3.5，都在b
b. 345 345->4
a满足[2,6]U[3,4]
c. 146 357->(4+5)/2

提示
1. 中位数一边增，一边就减，所以只要比较中间的数字就可以了
2. 要分成奇数和偶数讨论

问题：要怎么平衡？以各自的length为标准长度，一边增，一边减的长度不同
->可以只以小的为平衡点增减，直到碰到边界，还无法平衡，说明只可能在某一边
->一个数组overwhelming可以早讨论
->也不用，存在d，提前讨论没啥用，一样一边倒
d. 126 3789

结构
a小b大
初始中位
判断a==0和a==al-1两种情况
return (m1+m2)/2.0

a的奇偶性应该不影响，因为跳跃的路径应该可以被各种小的奇数/偶数段表示
无法达到am=bm，因此截去一半，自己应该被包含在内，即最后a的范围=2
e. 14 23 (2+3)/2
所以各自取am bm有加起来大1的问题

猜想：如果am<bn&&a(m-1)>b(n-1)就是bn和b(n+1)为中位数
4种情况，2种可以确定中位数，2种可以确定小的变化方向
f. 246 35->4，奇数只需要判断bn-1<=am<=bn
即判断式里，如果a元素是奇数个，则am-1也是am
g. 246 45->4相等可以
h. 246 34->4相等可以

把奇偶和一边大合在一起，先不考虑小数组，一共8钟：
1. 123 45678
2. 123 4567
3. 1234 56789：37->46，还是比的了的
4. 1234 5678：37->46
5. 678 12345：73->64

所以奇数是一个数字，偶数是两个数字。
但不管合起来数字有2,3,4个，最终的决定都只有向左向右和得到结果三种
2个 左右 得到结果：相等；撞墙











*/